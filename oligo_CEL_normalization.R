library(GEOquery)
library(oligo)
source("https://bioconductor.org/biocLite.R")
#data.dir <- "CEL"
#celfiles <- list.files(data.dir, "\\.gz$")
#data.raw <- read.celfiles(filenames=file.path(data.dir, celfiles))

getGEOSuppFiles("GSE117261")
untar("GSE117261/GSE117261_RAW.tar", exdir = "GSE117261/CEL")
#list.files("GSE117261/CEL")
celfiles <- list.files("GSE117261/CEL", full = TRUE) #, "\\.gz$")
data.raw <- read.celfiles(celfiles)
data.raw.exprs <- exprs(data.raw)
data.raw
pdf(file="GSE117261_boxplot_raw.pdf",bg="white");boxplot(data.raw,target='probeset');dev.off()
#=====================Normalization==========================================
#A classic and powerful method for preprocessing Affymetrix gene expression arrays is the RMA method. Experience tells us that RMA essentially always performs well so many people prefer this method; one can argue that it is better to use a method which always does well as opposed to a method which does extremely well on some datasets and poorly on others.
## Background correcting
## Normalizing
## Calculating Expression
data.eset <- rma(data.raw,target='probeset') #target:("probeset", "core", "full", "extended")
data.exprs <- exprs(data.eset) 
data.eset
pdf(file="GSE117261_boxplot_afterNormalizing.pdf",bg="white");boxplot(data.eset,target='probeset');dev.off()
featureData(data.eset) <- getNetAffx(data.eset, "probeset")
data.exprs <- exprs(data.eset)
fdata <-fData(data.eset)
write.csv(fdata,file='fdata.probeset.txt')
cnames <- c( c("probesetID", "GeneID","Level"), colnames(data.exprs))
write.table(data.frame(fdata$probesetid, fdata$geneassignment,fdata$level,data.exprs),file="GSE117261.probeset.normalized_expression.txt",row.names=FALSE, col.names=cnames, sep="\t")
#====P/A filtering=====================
#Methods for Present/Absent Calls are meant to provide means of assessing whether or not each of the (PM) intensities are compatible with observations generated by background probes.
xpa <- paCalls(data.raw,method="PSDABG")
write.csv(xpa,file='GSE117261.probeset.Pvalue.matrix.txt')

#AP <- apply(xpa, 1, function(x) any(x >=0))
#xids <- as.numeric(names(AP[AP]))
#pinfo <- getProbeInfo(data.raw)
#fids <- pinfo[pinfo$fid %in% xids, 2]
#xps <-  xps[rownames(xps) %in% fids, ]
#apply(calls, 1, function(x) sum(x < 0.05) > 2)
#xpa <- xpa[order(xpa[,1]),]
#xpa[xpa>=0.01] = 'A'
#xpa[xpa !="A"] = 'P'
#xpa[xpa=="P"]=T
#xpa[xpa=="A"]=F
#mode(xpa)  <- "logical"
#data.exprs[!xpa] <- NA
#data.exprs[detect.rate>=0.01,]->expr
#write.csv(data.exprs,file="GSE117261_Detection_normalized_expression.txt")


#allchipspa <-paCalls(allchips, method=?PSDABG?, verbose=TRUE)
#present <- rownames(allchipspa)
#allchips_present <- exprs(allchips[present,])

pdf(file="GSE117261_hist.pdf",bg="white")
par(mfrow=c(1,2))
hist(log2(intensity(data.raw[,4])),breaks=100,col="blue") 
hist(log2(data.exprs),breaks=100,col="green") 
dev.off()

